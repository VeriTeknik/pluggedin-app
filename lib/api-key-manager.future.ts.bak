/**
 * API Key Management - Rotation, Expiration, and Usage Tracking
 */

import { randomBytes } from 'crypto';
import { db } from '@/db';
// Note: apiKeys table needs to be added to the database schema
// For now, this module provides the interface for future implementation
import { eq, and, lt, isNull, or, gt } from 'drizzle-orm';
import log from './logger';
import { encrypt, decrypt } from './encryption-v2';

// Configuration
const API_KEY_LENGTH = 32; // Length in bytes (64 chars when hex encoded)
const API_KEY_PREFIX = 'pg_in_'; // Prefix for all API keys
const DEFAULT_EXPIRATION_DAYS = 90; // Default expiration period
const ROTATION_WARNING_DAYS = 14; // Warn before expiration
const MAX_KEYS_PER_USER = 5; // Maximum API keys per profile

/**
 * Generate a new secure API key
 */
export function generateApiKey(): string {
  const randomPart = randomBytes(API_KEY_LENGTH).toString('hex');
  return `${API_KEY_PREFIX}${randomPart}`;
}

/**
 * Create a new API key for a profile
 */
export async function createApiKey({
  profileUuid,
  name,
  expirationDays = DEFAULT_EXPIRATION_DAYS,
  metadata = {},
}: {
  profileUuid: string;
  name: string;
  expirationDays?: number;
  metadata?: Record<string, any>;
}): Promise<{
  success: boolean;
  apiKey?: string;
  id?: string;
  expiresAt?: Date;
  error?: string;
}> {
  try {
    // TODO: Uncomment when apiKeys table is added to schema
    /*
    // Check existing key count
    const existingKeys = await db.query.apiKeys.findMany({
      where: eq(apiKeys.profile_uuid, profileUuid),
    });

    if (existingKeys.length >= MAX_KEYS_PER_USER) {
      return {
        success: false,
        error: `Maximum of ${MAX_KEYS_PER_USER} API keys allowed per profile`,
      };
    }
    */

    // Generate new key
    const plainApiKey = generateApiKey();
    
    // Get encryption key from environment
    const encryptionKey = process.env.API_KEY_ENCRYPTION_SECRET || process.env.NEXTAUTH_SECRET;
    if (!encryptionKey) {
      throw new Error('API key encryption secret not configured');
    }

    // Encrypt the API key for storage
    const encryptedKey = encrypt(plainApiKey, encryptionKey);
    
    // Calculate expiration date
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + expirationDays);

    // TODO: Uncomment when apiKeys table is added to schema
    /*
    // Create key record
    const newKey = await db.insert(apiKeys).values({
      profile_uuid: profileUuid,
      name,
      key_preview: plainApiKey.substring(0, 10) + '...' + plainApiKey.substring(plainApiKey.length - 4),
      encrypted_key: encryptedKey,
      expires_at: expiresAt,
      encryption_version: 2, // Using new encryption
      metadata,
      usage_count: 0,
      created_at: new Date(),
    }).returning({
      id: apiKeys.id,
    });
    */

    // Temporary: Generate a mock ID
    const mockId = randomBytes(16).toString('hex');

    log.info('API key created', {
      profileUuid,
      keyId: mockId,
      name,
      expiresAt,
    });

    return {
      success: true,
      apiKey: plainApiKey, // Return plain key only on creation
      id: mockId,
      expiresAt,
    };
  } catch (error) {
    log.error('Failed to create API key', error as Error, { profileUuid, name });
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to create API key',
    };
  }
}

/**
 * Rotate an existing API key
 */
export async function rotateApiKey(
  keyId: string,
  profileUuid: string
): Promise<{
  success: boolean;
  newApiKey?: string;
  expiresAt?: Date;
  error?: string;
}> {
  try {
    // TODO: Uncomment when apiKeys table is added to schema
    /*
    // Find existing key
    const existingKey = await db.query.apiKeys.findFirst({
      where: and(
        eq(apiKeys.id, keyId),
        eq(apiKeys.profile_uuid, profileUuid)
      ),
    });

    if (!existingKey) {
      return {
        success: false,
        error: 'API key not found',
      };
    }
    */

    // Generate new key
    const plainApiKey = generateApiKey();
    
    // Get encryption key
    const encryptionKey = process.env.API_KEY_ENCRYPTION_SECRET || process.env.NEXTAUTH_SECRET;
    if (!encryptionKey) {
      throw new Error('API key encryption secret not configured');
    }

    // Encrypt new key
    const encryptedKey = encrypt(plainApiKey, encryptionKey);
    
    // Calculate new expiration
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + DEFAULT_EXPIRATION_DAYS);

    // TODO: Uncomment when apiKeys table is added to schema
    /*
    // Update key record
    await db.update(apiKeys)
      .set({
        key_preview: plainApiKey.substring(0, 10) + '...' + plainApiKey.substring(plainApiKey.length - 4),
        encrypted_key: encryptedKey,
        expires_at: expiresAt,
        last_rotated_at: new Date(),
        encryption_version: 2,
        usage_count: 0, // Reset usage count on rotation
      })
      .where(eq(apiKeys.id, keyId));
    */

    log.info('API key rotated', {
      keyId,
      profileUuid,
      expiresAt,
    });

    return {
      success: true,
      newApiKey: plainApiKey,
      expiresAt,
    };
  } catch (error) {
    log.error('Failed to rotate API key', error as Error, { keyId, profileUuid });
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to rotate API key',
    };
  }
}

/**
 * Check if an API key needs rotation
 */
export async function checkKeyRotationNeeded(keyId: string): Promise<{
  needsRotation: boolean;
  reason?: string;
  daysUntilExpiration?: number;
}> {
  try {
    const key = await db.query.apiKeys.findFirst({
      where: eq(apiKeys.id, keyId),
      columns: {
        expires_at: true,
        last_rotated_at: true,
        usage_count: true,
      },
    });

    if (!key) {
      return { needsRotation: false };
    }

    // Check expiration
    if (key.expires_at) {
      const now = new Date();
      const daysUntilExpiration = Math.floor(
        (key.expires_at.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );

      if (daysUntilExpiration <= 0) {
        return {
          needsRotation: true,
          reason: 'Key has expired',
          daysUntilExpiration: 0,
        };
      }

      if (daysUntilExpiration <= ROTATION_WARNING_DAYS) {
        return {
          needsRotation: true,
          reason: `Key expires in ${daysUntilExpiration} days`,
          daysUntilExpiration,
        };
      }
    }

    // Check usage count (rotate after heavy usage)
    if (key.usage_count && key.usage_count > 100000) {
      return {
        needsRotation: true,
        reason: 'High usage count',
      };
    }

    return { needsRotation: false };
  } catch (error) {
    log.error('Failed to check key rotation', error as Error, { keyId });
    return { needsRotation: false };
  }
}

/**
 * Track API key usage
 */
export async function trackApiKeyUsage(
  apiKey: string,
  endpoint: string,
  method: string,
  ipAddress: string,
  userAgent: string,
  responseStatus: number,
  responseTime: number
): Promise<void> {
  try {
    // Find key by encrypted value (would need to decrypt all keys to match)
    // For now, we'll track by key preview pattern
    const keyPreview = apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4);
    
    // Update usage count and last used timestamp
    await db.update(apiKeys)
      .set({
        usage_count: db.sql`${apiKeys.usage_count} + 1`,
        last_used_at: new Date(),
      })
      .where(eq(apiKeys.key_preview, keyPreview));

    // Log usage for audit
    log.info('API key usage', {
      type: 'API_KEY_USAGE',
      endpoint,
      method,
      ip_address: ipAddress,
      user_agent: userAgent,
      response_status: responseStatus,
      response_time_ms: responseTime,
    });
  } catch (error) {
    log.error('Failed to track API key usage', error as Error);
  }
}

/**
 * Validate an API key
 */
export async function validateApiKey(apiKey: string): Promise<{
  isValid: boolean;
  keyId?: string;
  profileUuid?: string;
  error?: string;
}> {
  try {
    // Check format
    if (!apiKey.startsWith(API_KEY_PREFIX)) {
      return {
        isValid: false,
        error: 'Invalid API key format',
      };
    }

    // Get all active keys (not expired)
    const activeKeys = await db.query.apiKeys.findMany({
      where: or(
        isNull(apiKeys.expires_at),
        gt(apiKeys.expires_at, new Date())
      ),
    });

    // Get encryption key
    const encryptionKey = process.env.API_KEY_ENCRYPTION_SECRET || process.env.NEXTAUTH_SECRET;
    if (!encryptionKey) {
      throw new Error('API key encryption secret not configured');
    }

    // Check each key (decrypt and compare)
    for (const key of activeKeys) {
      try {
        const decryptedKey = decrypt(key.encrypted_key, encryptionKey);
        if (decryptedKey === apiKey) {
          return {
            isValid: true,
            keyId: key.id,
            profileUuid: key.profile_uuid,
          };
        }
      } catch {
        // Skip keys that can't be decrypted (might be legacy format)
        continue;
      }
    }

    return {
      isValid: false,
      error: 'API key not found or expired',
    };
  } catch (error) {
    log.error('Failed to validate API key', error as Error);
    return {
      isValid: false,
      error: 'Failed to validate API key',
    };
  }
}

/**
 * List API keys for a profile
 */
export async function listApiKeys(profileUuid: string): Promise<{
  success: boolean;
  keys?: Array<{
    id: string;
    name: string;
    keyPreview: string;
    expiresAt: Date | null;
    lastUsedAt: Date | null;
    usageCount: number;
    needsRotation: boolean;
    createdAt: Date;
  }>;
  error?: string;
}> {
  try {
    const keys = await db.query.apiKeys.findMany({
      where: eq(apiKeys.profile_uuid, profileUuid),
      columns: {
        id: true,
        name: true,
        key_preview: true,
        expires_at: true,
        last_used_at: true,
        usage_count: true,
        created_at: true,
      },
      orderBy: (apiKeys, { desc }) => [desc(apiKeys.created_at)],
    });

    // Check rotation status for each key
    const keysWithStatus = await Promise.all(
      keys.map(async (key) => {
        const rotationCheck = await checkKeyRotationNeeded(key.id);
        return {
          id: key.id,
          name: key.name,
          keyPreview: key.key_preview,
          expiresAt: key.expires_at,
          lastUsedAt: key.last_used_at,
          usageCount: key.usage_count || 0,
          needsRotation: rotationCheck.needsRotation,
          createdAt: key.created_at,
        };
      })
    );

    return {
      success: true,
      keys: keysWithStatus,
    };
  } catch (error) {
    log.error('Failed to list API keys', error as Error, { profileUuid });
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to list API keys',
    };
  }
}

/**
 * Delete an API key
 */
export async function deleteApiKey(
  keyId: string,
  profileUuid: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await db.delete(apiKeys)
      .where(and(
        eq(apiKeys.id, keyId),
        eq(apiKeys.profile_uuid, profileUuid)
      ));

    log.info('API key deleted', { keyId, profileUuid });

    return { success: true };
  } catch (error) {
    log.error('Failed to delete API key', error as Error, { keyId, profileUuid });
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete API key',
    };
  }
}

// gt is already imported above

export default {
  generateApiKey,
  createApiKey,
  rotateApiKey,
  checkKeyRotationNeeded,
  trackApiKeyUsage,
  validateApiKey,
  listApiKeys,
  deleteApiKey,
  API_KEY_PREFIX,
  DEFAULT_EXPIRATION_DAYS,
  MAX_KEYS_PER_USER,
};